<html><head>
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
            <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;display=swap" rel="stylesheet">
            <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&amp;display=swap" rel="stylesheet">                   
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
            <style>
                /* Default styles */
                pre {
                    background: #2d2d2d;
                    border-radius: 4px;
                    margin: 0.5em 0;
                }
                code {
                    font-family: 'Fira Code', Consolas, Monaco, monospace;
                }
                /* Custom CSS */
                /* Improved Custom CSS */
body {
	font-family: "Barlow", sans-serif;
	line-height: 1.7;
	padding: 24px;
	margin: 0;
	background: #fafafa;
	color: #222;
}

/* Code Blocks */
pre {
	background: #1e1e1e;
	color: #f8f8f2;
	border-radius: 6px;
	padding: 12px 14px;
	overflow-x: auto;
	margin: 1em 0;
	box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

code {
	font-family: 'Fira Code', Consolas, Monaco, monospace;
	white-space: pre-wrap;
	word-wrap: break-word;
}

/* Inline Code */
:not(pre) > code {
	background: #f3f3f3;
	padding: 3px 6px;
	border-radius: 4px;
	color: #d63384;
	font-size: 0.95em;
}

/* Images */
img {
	max-width: 100%;
	border-radius: 6px;
	display: block;
	margin: 12px 0;
}

/* Tables */
table {
	border-collapse: collapse;
	width: 100%;
	margin: 1.2em 0;
	background: white;
	border-radius: 6px;
	overflow: hidden;
	box-shadow: 0 1px 4px rgba(0,0,0,0.1);
}

th, td {
	border: 1px solid #e4e4e4;
	padding: 10px 12px;
	text-align: left;
}

th {
	background-color: #f7f7f7;
	font-weight: 600;
}

/* Blockquotes */
blockquote {
	border-left: 4px solid #6c757d;
	padding-left: 1em;
	margin-left: 0;
	color: #555;
	font-style: italic;
	background: #f7f7f7;
	border-radius: 4px;
	padding-top: 8px;
	padding-bottom: 8px;
}

/* Headings */
h1, h2, h3 {
	font-weight: 600;
	margin-top: 2rem;
	margin-bottom: .75rem;
	line-height: 1.3;
}

h1 {
	font-size: 2.3em;
	color: #2c3e50;
	border-bottom: 2px solid #e7e7e7;
	padding-bottom: .5rem;
}

h2 {
	font-size: 1.9em;
	color: #34495e;
}

h3 {
	font-size: 1.45em;
	color: #455a64;
}

/* Links */
a {
	color: #0077cc;
	text-decoration: none;
	transition: color 0.2s ease;
}

a:hover {
	color: #005999;
	text-decoration: underline;
}

            </style>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
        </head>
        <body>
            <h2><strong>2 marks</strong></h2>
<h2><strong>1) Linked List and Types of Linked List</strong></h2>
<p>A linked list is a dynamic data structure used to store elements in memory. Each element is stored in a node. A node contains two fields: <strong>data</strong> and <strong>link</strong>. The link field stores the address of the next node. The linked list grows and shrinks during program execution because memory is allocated at runtime. This avoids wastage of memory which is seen in arrays.</p>
<h3><strong>Types of Linked List</strong></h3>
<ol>
<li><p><strong>Singly Linked List</strong><br>Each node contains data and a pointer to the next node.<br>Example:<br><code>head → |data|next| → |data|next| → NULL</code></p>
</li>
<li><p><strong>Doubly Linked List</strong><br>Each node has two links. One link points to previous node and the other to the next node.</p>
</li>
<li><p><strong>Circular Linked List</strong><br>The last node does not point to NULL. Instead, it points back to the first node forming a circular chain.</p>
</li>
</ol>
<p>Linked lists are used in implementing stacks, queues and memory management.</p>
<hr>
<h2><strong>2) ADT Stack and Queue with Operations</strong></h2>
<h3><strong>Stack</strong></h3>
<p>A stack is a <strong>LIFO</strong> structure. The insertion and deletion operations happen at the same end called <strong>top</strong>.</p>
<p><strong>Operations:</strong></p>
<ul>
<li><code>push(x)</code> inserts x at the top.</li>
<li><code>pop()</code> removes and returns the element at the top.</li>
<li><code>peek()</code> returns the top element without removing it.</li>
</ul>
<p>Example:</p>
<pre><code>push(5) -&gt; stack: 5
push(10) -&gt; stack: 10, 5
pop() -&gt; returns 10 -&gt; stack: 5
</code></pre>
<h3><strong>Queue</strong></h3>
<p>A queue is a <strong>FIFO</strong> structure. Insertion takes place at <strong>rear</strong>, deletion at <strong>front</strong>.</p>
<p><strong>Operations:</strong></p>
<ul>
<li><code>enqueue(x)</code> inserts x at the rear.</li>
<li><code>dequeue()</code> removes element from the front.</li>
</ul>
<p>Queues are used in scheduling, buffering and traffic management.</p>
<hr>
<h2><strong>3) Binary Tree and Binary Search Tree</strong></h2>
<p>A binary tree is a hierarchical structure in which each node has up to <strong>two children</strong>, named left child and right child.</p>
<h3><strong>Binary Search Tree (BST) Properties</strong></h3>
<ul>
<li>The left subtree contains values <strong>less</strong> than the root.</li>
<li>The right subtree contains values <strong>greater</strong> than the root.</li>
<li>No duplicate values.</li>
</ul>
<p>BST is used for searching, insertion and deletion efficiently.</p>
<h3><strong>Example Tree</strong></h3>
<pre><code>       50
      /  \
    30    70
   / \    / \
 20  40  60  80
</code></pre>
<p><strong>Inorder traversal prints sorted output.</strong></p>
<hr>
<h2><strong>4) Rehashing</strong></h2>
<p>In hashing, when too many collisions occur or when the hash table becomes full, performance decreases. Rehashing is used to solve this.</p>
<h3><strong>Steps in Rehashing</strong></h3>
<ol>
<li>Create a new hash table of <strong>larger size</strong>.</li>
<li>Recompute the index for each existing key and insert them into the new table.</li>
<li>The load factor becomes lower and searching becomes faster again.</li>
</ol>
<p>Rehashing ensures efficient use of hashing even when the data grows.</p>
<hr>
<h2><strong>5) Expression Tree Using Stack</strong></h2>
<p>An expression tree is used to represent arithmetic expressions.<br>Leaf nodes represent <strong>operands</strong> (numbers or variables).<br>Internal nodes represent <strong>operators</strong> (+, -, *, /).</p>
<h3><strong>Construction from Postfix Expression</strong></h3>
<ol>
<li>Scan postfix expression left to right.</li>
<li>If symbol is operand, push as a node to stack.</li>
<li>If symbol is operator, pop two nodes, make them children, and push the new tree back.</li>
</ol>
<h3><strong>Example</strong></h3>
<p>Postfix: <code>AB+CD-*</code></p>
<p>Expression Tree formed:</p>
<pre><code>        *
      /   \
     +     -
    / \   / \
   A   B C   D
</code></pre>
<p>To evaluate, perform postorder traversal.</p>
<hr>
<h2><strong>Answer In Detail</strong></h2>
<h2><strong>1) Deletion at Beginning</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Deletion at the beginning means removing the <strong>first node</strong> of the linked list.<br>The head pointer is moved to the next node and the old first node is freed.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If head == NULL, print "List is empty"
Step 2: Set Temp = head
Step 3: Move head to next node
        head = head -&gt; link
Step 4: Free Temp
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_at_begin() {
    struct node *Temp;
    if(head == NULL) {
        printf("List is empty\n");
    }
    else {
        Temp = head;
        head = head -&gt; link;
        free(Temp);
    }
}
</code></pre>
<hr>
<h2><strong>2) Deletion at End</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Deletion at the end means removing the <strong>last node</strong> of the linked list.<br>We find the second last node and make its link NULL, then free the last node.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If head == NULL, print "List is empty"
Step 2: If head -&gt; link == NULL, free head and set head = NULL
Step 3: Else set Temp = head
Step 4: Traverse until Temp -&gt; link -&gt; link == NULL
Step 5: Set Temp1 = Temp -&gt; link
Step 6: Set Temp -&gt; link = NULL
Step 7: Free Temp1
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_at_end() {
    struct node *Temp, *Temp1;

    if(head == NULL) {
        printf("List is empty\n");
    }
    else if(head -&gt; link == NULL) {
        free(head);
        head = NULL;
    }
    else {
        Temp = head;
        while(Temp -&gt; link -&gt; link != NULL) {
            Temp = Temp -&gt; link;
        }
        Temp1 = Temp -&gt; link;
        Temp -&gt; link = NULL;
        free(Temp1);
    }
}
</code></pre>
<hr>
<h2><strong>3) Deletion in Middle (Delete node with value y)</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Deletion in the middle means removing the node which contains the <strong>value y</strong>.<br>We find that node, adjust the links, and free the node.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If head == NULL, print "List is empty"
Step 2: Set Temp = head
Step 3: If Temp -&gt; data == y then
        head = head -&gt; link, free Temp
Step 4: Else traverse until Temp -&gt; link -&gt; data == y
Step 5: Set Temp1 = Temp -&gt; link
Step 6: Temp -&gt; link = Temp1 -&gt; link
Step 7: Free Temp1
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_value(int y) {
    struct node *Temp, *Temp1;

    if(head == NULL) {
        printf("List is empty\n");
        return;
    }

    Temp = head;

    if(Temp -&gt; data == y) {
        head = head -&gt; link;
        free(Temp);
    }
    else {
        while(Temp -&gt; link != NULL &amp;&amp; Temp -&gt; link -&gt; data != y) {
            Temp = Temp -&gt; link;
        }

        if(Temp -&gt; link == NULL) {
            printf("Value %d not found\n", y);
        }
        else {
            Temp1 = Temp -&gt; link;
            Temp -&gt; link = Temp1 -&gt; link;
            free(Temp1);
        }
    }
}
</code></pre>
<hr>
<h2><strong>Topic:</strong> Searching in Singly Linked List</h2>
<h3><strong>Definition</strong></h3>
<p>Searching in a singly linked list means finding whether a given value <strong>x</strong> is present in any node of the list.<br>We start from the head node and move through each node one by one until the value is found or the list ends.</p>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Set Temp = head
Step 2: While Temp is not NULL do
            If Temp -&gt; data == x
                 Print "Element Found"
                 Stop
            Temp = Temp -&gt; link
Step 3: If Temp == NULL
            Print "Element Not Found"
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void search(int x) {
    struct node *Temp;
    Temp = head;

    while(Temp != NULL) {
        if(Temp -&gt; data == x) {
            printf("Element %d found in the list\n", x);
            return;
        }
        Temp = Temp -&gt; link;
    }
    printf("Element %d not found in the list\n", x);
}
</code></pre>
<p>Doubly Linked List</p>
<ol>
<li>Insertion at Beginning</li>
<li>Insertion at End</li>
<li>Insertion in Middle (After a given value)</li>
<li>Deletion at Beginning</li>
<li>Deletion at End</li>
<li>Deletion of Specific Value</li>
<li>Searching</li>
</ol>
<hr>
<h3><strong>Structure Definition (Common for all)</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int data;
    struct node *prev;
    struct node *next;
};

struct node *head = NULL;
</code></pre>
<hr>
<h2><strong>1) Insertion at Beginning</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Insertion at the beginning means adding a new node before the first node and updating head.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Create newnode
Step 2: newnode-&gt;data = x
Step 3: newnode-&gt;prev = NULL
Step 4: newnode-&gt;next = head
Step 5: If head != NULL then head-&gt;prev = newnode
Step 6: head = newnode
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void insert_begin(int x) {
    struct node *newnode = (struct node*)malloc(sizeof(struct node));
    newnode-&gt;data = x;
    newnode-&gt;prev = NULL;
    newnode-&gt;next = head;

    if(head != NULL)
        head-&gt;prev = newnode;

    head = newnode;
}
</code></pre>
<hr>
<h2><strong>2) Insertion at End</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Insertion at the end means adding a new node after the last node.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Create newnode
Step 2: newnode-&gt;data = x, newnode-&gt;next = NULL
Step 3: If head == NULL, head = newnode
Step 4: Else traverse to last node (Temp)
Step 5: Temp-&gt;next = newnode
Step 6: newnode-&gt;prev = Temp
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void insert_end(int x) {
    struct node *newnode = (struct node*)malloc(sizeof(struct node));
    struct node *Temp = head;

    newnode-&gt;data = x;
    newnode-&gt;next = NULL;

    if(head == NULL) {
        newnode-&gt;prev = NULL;
        head = newnode;
    }
    else {
        while(Temp-&gt;next != NULL)
            Temp = Temp-&gt;next;

        Temp-&gt;next = newnode;
        newnode-&gt;prev = Temp;
    }
}
</code></pre>
<hr>
<h2><strong>3) Insertion After a Value y</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Insert the new node after the node that contains value <code>y</code>.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Traverse list to find node with data y (Temp)
Step 2: Create newnode
Step 3: newnode-&gt;next = Temp-&gt;next
Step 4: newnode-&gt;prev = Temp
Step 5: If Temp-&gt;next != NULL then Temp-&gt;next-&gt;prev = newnode
Step 6: Temp-&gt;next = newnode
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void insert_after(int x, int y) {
    struct node *Temp = head, *newnode;

    while(Temp != NULL &amp;&amp; Temp-&gt;data != y)
        Temp = Temp-&gt;next;

    if(Temp == NULL) {
        printf("Value %d not found\n", y);
        return;
    }

    newnode = (struct node*)malloc(sizeof(struct node));
    newnode-&gt;data = x;

    newnode-&gt;next = Temp-&gt;next;
    newnode-&gt;prev = Temp;

    if(Temp-&gt;next != NULL)
        Temp-&gt;next-&gt;prev = newnode;

    Temp-&gt;next = newnode;
}
</code></pre>
<hr>
<h2><strong>4) Deletion at Beginning</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Removes the first node and moves head to the next node.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If head == NULL print empty
Step 2: Temp = head
Step 3: head = head-&gt;next
Step 4: If head != NULL head-&gt;prev = NULL
Step 5: Free Temp
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_begin() {
    struct node *Temp;

    if(head == NULL) {
        printf("List is empty\n");
        return;
    }

    Temp = head;
    head = head-&gt;next;

    if(head != NULL)
        head-&gt;prev = NULL;

    free(Temp);
}
</code></pre>
<hr>
<h2><strong>5) Deletion at End</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Removes the last node of the list.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If head == NULL print empty
Step 2: Traverse to last node (Temp)
Step 3: Temp-&gt;prev-&gt;next = NULL
Step 4: Free Temp
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_end() {
    struct node *Temp = head;

    if(head == NULL) {
        printf("List is empty\n");
        return;
    }

    while(Temp-&gt;next != NULL)
        Temp = Temp-&gt;next;

    if(Temp-&gt;prev != NULL)
        Temp-&gt;prev-&gt;next = NULL;
    else
        head = NULL;

    free(Temp);
}
</code></pre>
<hr>
<h2><strong>6) Deletion of Value y</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Removes the node that contains value <code>y</code>.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Traverse to find Temp with data y
Step 2: Temp-&gt;prev-&gt;next = Temp-&gt;next
Step 3: Temp-&gt;next-&gt;prev = Temp-&gt;prev (if not NULL)
Step 4: Free Temp
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void delete_value(int y) {
    struct node *Temp = head;

    while(Temp != NULL &amp;&amp; Temp-&gt;data != y)
        Temp = Temp-&gt;next;

    if(Temp == NULL) {
        printf("Value %d not found\n", y);
        return;
    }

    if(Temp-&gt;prev != NULL)
        Temp-&gt;prev-&gt;next = Temp-&gt;next;
    else
        head = Temp-&gt;next;

    if(Temp-&gt;next != NULL)
        Temp-&gt;next-&gt;prev = Temp-&gt;prev;

    free(Temp);
}
</code></pre>
<hr>
<h2><strong>7) Searching</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Searching means checking whether a particular value exists in the list.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Temp = head
Step 2: Traverse until Temp == NULL
Step 3: If Temp-&gt;data == x, found
Step 4: Else not found
</code></pre>
<h3><strong>Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void search(int x) {
    struct node *Temp = head;

    while(Temp != NULL) {
        if(Temp-&gt;data == x) {
            printf("Element %d found\n", x);
            return;
        }
        Temp = Temp-&gt;next;
    }
    printf("Element %d not found\n", x);
}
</code></pre>
<hr>
<h2><strong>1) Hashing using Linear Probing</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Linear probing is a collision handling technique where, if the calculated hash index is occupied, we <strong>check the next position (index + 1)</strong> and continue moving forward until an empty slot is found.</p>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Compute index = key % size
Step 2: While hash[index] is occupied
            index = (index + 1) % size
Step 3: Insert key at hash[index]
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">#define size 10
int hash[size];

void init() {
    for(int i=0; i&lt;size; i++)
        hash[i] = -1;
}

void insert_linear(int key) {
    int index = key % size;
    while(hash[index] != -1) {
        index = (index + 1) % size;
    }
    hash[index] = key;
}
</code></pre>
<hr>
<h2><strong>2) Hashing using Quadratic Probing</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Quadratic probing resolves collisions by checking squares of step values i.e.,<br>(index + 1²), (index + 2²), (index + 3²), etc., until an empty space is found.</p>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Compute index = key % size
Step 2: Set i = 1
Step 3: While hash[index] is occupied
            index = (index + i*i) % size
            i = i + 1
Step 4: Insert key at hash[index]
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void insert_quadratic(int key) {
    int index = key % size;
    int i = 1;
    while(hash[index] != -1) {
        index = (index + i*i) % size;
        i++;
    }
    hash[index] = key;
}
</code></pre>
<hr>
<h2><strong>3) Double Hashing</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Double hashing uses <strong>two hash functions</strong>.<br>If collision occurs, we move using steps of the second hash function.</p>
<pre><code>New Index = (h1(key) + i * h2(key)) % size
</code></pre>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: h1 = key % size
Step 2: h2 = 7 - (key % 7)
Step 3: Set i = 0
Step 4: While hash[(h1 + i*h2) % size] is occupied
            i = i + 1
Step 5: Insert key at (h1 + i*h2) % size
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void insert_double(int key) {
    int h1 = key % size;
    int h2 = 7 - (key % 7);
    int index, i = 0;

    while(1) {
        index = (h1 + i*h2) % size;
        if(hash[index] == -1) {
            hash[index] = key;
            break;
        }
        i++;
    }
}
</code></pre>
<hr>
<h3><strong>To Print the Hash Table</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void display() {
    for(int i=0; i&lt;size; i++)
        printf("%d ", hash[i]);
    printf("\n");
}
</code></pre>
<hr>
<p> <strong>Binary Search Tree (BST)</strong></p>
<ol>
<li>Insertion</li>
<li>Inorder Traversal</li>
<li>Searching</li>
<li>Deletion</li>
</ol>
<hr>
<h2><strong>Structure Definition (Common)</strong></h2>
<pre class="language-c" tabindex="0"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int data;
    struct node *left, *right;
};

struct node *root = NULL;
</code></pre>
<hr>
<h2><strong>1) Insertion in BST</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Insertion in BST means placing a new node in the tree such that:</p>
<ul>
<li>Values smaller go to the <strong>left subtree</strong></li>
<li>Values larger go to the <strong>right subtree</strong></li>
</ul>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Create new node
Step 2: If root is NULL, root = new node
Step 3: Else compare new value with root
Step 4: If value &lt; root data, go to left subtree
Step 5: If value &gt; root data, go to right subtree
Step 6: Repeat until correct leaf position is found
Step 7: Insert node
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">struct node* insert(struct node* root, int x) {
    if(root == NULL) {
        root = (struct node*)malloc(sizeof(struct node));
        root-&gt;data = x;
        root-&gt;left = root-&gt;right = NULL;
        return root;
    }
    if(x &lt; root-&gt;data)
        root-&gt;left = insert(root-&gt;left, x);
    else if(x &gt; root-&gt;data)
        root-&gt;right = insert(root-&gt;right, x);
    return root;
}
</code></pre>
<hr>
<h2><strong>2) Inorder Traversal</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Inorder traversal visits nodes in the order:</p>
<pre><code>Left Subtree → Root → Right Subtree
</code></pre>
<p>This prints BST in <strong>ascending order</strong>.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Traverse left subtree
Step 2: Visit (print) the root
Step 3: Traverse right subtree
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void inorder(struct node* root) {
    if(root != NULL) {
        inorder(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorder(root-&gt;right);
    }
}
</code></pre>
<hr>
<h2><strong>3) Searching in BST</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Searching in BST is done by comparing the value and moving either left or right.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: If root is NULL, element not found
Step 2: If x == root-&gt;data, element found
Step 3: If x &lt; root-&gt;data, search left subtree
Step 4: If x &gt; root-&gt;data, search right subtree
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">struct node* search(struct node* root, int x) {
    if(root == NULL || root-&gt;data == x)
        return root;

    if(x &lt; root-&gt;data)
        return search(root-&gt;left, x);
    else
        return search(root-&gt;right, x);
}
</code></pre>
<hr>
<h2><strong>4) Deletion in BST</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Deletion removes a node from BST while maintaining BST properties.</p>
<h3><strong>Cases</strong></h3>
<ol>
<li>Node has <strong>no child</strong> → delete directly</li>
<li>Node has <strong>one child</strong> → replace with child</li>
<li>Node has <strong>two children</strong> → replace with <strong>smallest value in right subtree</strong></li>
</ol>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Search node to delete
Step 2: If node has no child → free node
Step 3: If node has one child → replace node with child
Step 4: If node has two children
        Find inorder successor (smallest in right subtree)
        Replace node value with successor value
        Delete successor node
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">struct node* findMin(struct node* root) {
    while(root-&gt;left != NULL)
        root = root-&gt;left;
    return root;
}

struct node* delete(struct node* root, int x) {
    if(root == NULL) return root;

    if(x &lt; root-&gt;data)
        root-&gt;left = delete(root-&gt;left, x);
    else if(x &gt; root-&gt;data)
        root-&gt;right = delete(root-&gt;right, x);
    else {
        if(root-&gt;left == NULL) { struct node* temp = root-&gt;right; free(root); return temp; }
        else if(root-&gt;right == NULL){ struct node* temp = root-&gt;left; free(root); return temp; }

        struct node* temp = findMin(root-&gt;right);
        root-&gt;data = temp-&gt;data;
        root-&gt;right = delete(root-&gt;right, temp-&gt;data);
    }
    return root;
}
</code></pre>
<hr>
<ol>
<li><strong>Inorder Traversal</strong></li>
<li><strong>Preorder Traversal</strong></li>
<li><strong>Postorder Traversal</strong></li>
</ol>
<hr>
<h2><strong>Binary Tree Traversals</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Tree Traversal is the process of visiting each node in a tree exactly once.<br>There are <strong>three</strong> common Depth-First Traversal methods:</p>
<ol>
<li><strong>Inorder</strong>   : Left → Root → Right</li>
<li><strong>Preorder</strong>  : Root → Left → Right</li>
<li><strong>Postorder</strong> : Left → Right → Root</li>
</ol>
<hr>
<h2><strong>1) Inorder Traversal</strong></h2>
<h3><strong>Definition</strong></h3>
<p>In inorder traversal, we first visit the <strong>left subtree</strong>, then the <strong>root</strong>, and finally the <strong>right subtree</strong>.<br>For Binary Search Trees, inorder gives <strong>ascending order</strong> of values.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Traverse the left subtree
Step 2: Visit the root node
Step 3: Traverse the right subtree
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void inorder(struct node* root) {
    if(root != NULL) {
        inorder(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorder(root-&gt;right);
    }
}
</code></pre>
<hr>
<h2><strong>2) Preorder Traversal</strong></h2>
<h3><strong>Definition</strong></h3>
<p>In preorder traversal, the <strong>root</strong> is visited first, then the <strong>left subtree</strong>, followed by the <strong>right subtree</strong>.<br>This traversal is used to create <strong>prefix expressions</strong> and for <strong>copying trees</strong>.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Visit the root node
Step 2: Traverse the left subtree
Step 3: Traverse the right subtree
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void preorder(struct node* root) {
    if(root != NULL) {
        printf("%d ", root-&gt;data);
        preorder(root-&gt;left);
        preorder(root-&gt;right);
    }
}
</code></pre>
<hr>
<h2><strong>3) Postorder Traversal</strong></h2>
<h3><strong>Definition</strong></h3>
<p>In postorder traversal, we first visit the <strong>left subtree</strong>, then the <strong>right subtree</strong>, and finally the <strong>root</strong>.<br>This traversal is used to <strong>delete or free the tree</strong> safely.</p>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Traverse the left subtree
Step 2: Traverse the right subtree
Step 3: Visit the root node
</code></pre>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">void postorder(struct node* root) {
    if(root != NULL) {
        postorder(root-&gt;left);
        postorder(root-&gt;right);
        printf("%d ", root-&gt;data);
    }
}
</code></pre>
<hr>
<h2><strong>Node Structure (Common)</strong></h2>
<pre class="language-c" tabindex="0"><code class="language-c">struct node {
    int data;
    struct node *left, *right;
};
</code></pre>
<hr>
<h2><strong>Example Tree Diagram</strong> <em>(Draw this in exam)</em></h2>
<pre><code>        50
       /  \
     30    70
    / \    / \
  20  40  60  80
</code></pre>
<h3>Traversal Results:</h3>
<pre><code>Inorder   : 20 30 40 50 60 70 80
Preorder  : 50 30 20 40 70 60 80
Postorder : 20 40 30 60 80 70 50
</code></pre>
<h2><strong>Topic 1: Infix to Postfix Conversion</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Infix expression is an expression where the operator appears <strong>between</strong> the operands.<br>Example: <code>A + B</code></p>
<p>Postfix expression is an expression where the operator appears <strong>after</strong> the operands.<br>Example: <code>A B +</code></p>
<p>To convert infix to postfix, we use a <strong>stack</strong> to manage operators and precedence.</p>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Scan the infix expression from left to right.
Step 2: If the symbol is an operand, add it to the postfix output.
Step 3: If the symbol is '(', push it onto stack.
Step 4: If the symbol is ')', pop from stack until '(' is found.
Step 5: If the symbol is an operator:
        While the stack is not empty and precedence of operator on stack
        is greater or equal to current operator:
              pop and add to postfix.
        Push the current operator to stack.
Step 6: After scanning all characters, pop all remaining operators from stack.
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

char stack[50];
int top = -1;

void push(char x) {
    stack[++top] = x;
}

char pop() {
    return stack[top--];
}

int precedence(char x) {
    if(x=='+' || x=='-') return 1;
    if(x=='*' || x=='/') return 2;
    if(x=='^') return 3;
    return 0;
}

void infixToPostfix(char infix[]) {
    char postfix[50];
    int i, j=0;
    char x;

    for(i=0; infix[i]!='\0'; i++) {
        if(isalnum(infix[i])) {
            postfix[j++] = infix[i];
        }
        else if(infix[i] == '(') {
            push(infix[i]);
        }
        else if(infix[i] == ')') {
            while((x = pop()) != '(')
                postfix[j++] = x;
        }
        else {
            while(top != -1 &amp;&amp; precedence(stack[top]) &gt;= precedence(infix[i]))
                postfix[j++] = pop();
            push(infix[i]);
        }
    }

    while(top != -1)
        postfix[j++] = pop();

    postfix[j] = '\0';
    printf("Postfix: %s\n", postfix);
}

int main() {
    char exp[] = "A+B*C";
    infixToPostfix(exp);
    return 0;
}
</code></pre>
<hr>
<h2><strong>Topic 2: Postfix Expression Evaluation</strong></h2>
<h3><strong>Definition</strong></h3>
<p>Postfix evaluation means computing the value of a postfix expression.<br>We use a stack:</p>
<ul>
<li>Push operands</li>
<li>When operator comes, pop two operands, apply operation, and push result back.</li>
</ul>
<hr>
<h3><strong>Algorithm</strong></h3>
<pre><code>Step 1: Scan expression from left to right.
Step 2: If operand, push into stack.
Step 3: If operator:
        Pop top two elements.
        Apply operator: result = operand2 operator operand1
        Push result back to stack.
Step 4: At end, top of stack contains the result.
</code></pre>
<hr>
<h3><strong>C Code</strong></h3>
<pre class="language-c" tabindex="0"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int stack1[50];
int top1 = -1;

void push1(int x) {
    stack1[++top1] = x;
}

int pop1() {
    return stack1[top1--];
}

int evaluatePostfix(char postfix[]) {
    int i, op1, op2;

    for(i=0; postfix[i]!='\0'; i++) {
        if(isdigit(postfix[i])) {
            push1(postfix[i]-'0');
        }
        else {
            op1 = pop1();
            op2 = pop1();
            switch(postfix[i]) {
                case '+': push1(op2 + op1); break;
                case '-': push1(op2 - op1); break;
                case '*': push1(op2 * op1); break;
                case '/': push1(op2 / op1); break;
            }
        }
    }
    return pop1();
}

int main() {
    char exp[] = "23*54*+";
    printf("Result = %d\n", evaluatePostfix(exp));
    return 0;
}
</code></pre>

            <script>
                Prism.highlightAll();
            </script>
        
        
    </body></html>
